import os
import time
import json
import pandas as pd
import openai
import undetected_chromedriver as uc
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import re

class HistoriasClinicasExtractor:
    def __init__(self, output_folder="datos_extraidos"):
        print("üîÑ Inicializando el extractor de historias cl√≠nicas...")
        
        # Configurar opciones de Chrome
        options = uc.ChromeOptions()
        options.add_argument("--window-size=1920,1080")
        options.add_argument("--disable-notifications")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        
        # Inicializar Selenium con undetected-chromedriver
        try:
            self.driver = uc.Chrome(options=options)
            print("‚úÖ Navegador inicializado correctamente")
        except Exception as e:
            print(f"‚ùå Error al inicializar el navegador: {str(e)}")
            raise e
            
        self.wait = WebDriverWait(self.driver, 10)
        
        # Configurar rutas de salida
        self.output_folder = output_folder
        self.pacientes_csv = os.path.join(output_folder, "pacientes.csv")
        self.consultas_csv = os.path.join(output_folder, "consultas.csv")
        
        # Asegurarse de que existe la carpeta de salida
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)
        
        # Inicializar DataFrames
        self.pacientes_df = pd.DataFrame(columns=[
            "Paciente", "Fecha", "ID_Paciente", "Edad"
        ])
        
        self.consultas_df = pd.DataFrame(columns=[
            "ID_Paciente", "No_Consulta", "Tabaquismo", "Diabetes", 
            "PSA", "Presion_Arterial", "Diagnostico", "Tratamiento"
        ])
    
    def login(self, email, password):
        print(f"üîë Iniciando sesi√≥n con usuario: {email}")
        try:
            # Abrir la p√°gina
            self.driver.get("https://programahistoriasclinicas.com/")
            time.sleep(5)  # Esperamos m√°s tiempo para que cargue completamente
            
            # Tomar captura de pantalla de diagn√≥stico
            self.driver.save_screenshot("login_page.png")
            print(f"üì∏ Captura de pantalla guardada en login_page.png")
            
            # Intentar encontrar el bot√≥n de iniciar sesi√≥n de diferentes maneras
            try:
                # M√©todo 1: XPATH
                iniciar_sesion_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'Iniciar Sesi√≥n')]"))
                )
                print("‚úÖ Bot√≥n encontrado con XPATH")
            except:
                try:
                    # M√©todo 2: CSS Selector
                    iniciar_sesion_btn = self.wait.until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, ".btn-iniciar-sesion, a.login-button"))
                    )
                    print("‚úÖ Bot√≥n encontrado con CSS Selector")
                except:
                    try:
                        # M√©todo 3: Bot√≥n verde
                        iniciar_sesion_btn = self.wait.until(
                            EC.element_to_be_clickable((By.CSS_SELECTOR, ".btn-success, .btn-primary"))
                        )
                        print("‚úÖ Bot√≥n encontrado por clase btn-success/primary")
                    except:
                        # M√©todo 4: JavaScript (√∫ltimo recurso)
                        print("‚ö†Ô∏è Usando JavaScript para hacer clic en el bot√≥n")
                        self.driver.execute_script("""
                            var buttons = document.querySelectorAll('a.btn, button.btn');
                            for(var i=0; i<buttons.length; i++) {
                                if(buttons[i].textContent.includes('Iniciar Sesi√≥n') || 
                                buttons[i].textContent.includes('Login') ||
                                buttons[i].classList.contains('btn-success')) {
                                    buttons[i].click();
                                    return true;
                                }
                            }
                            return false;
                        """)
                        time.sleep(3)
            
            # Si encontramos el bot√≥n con los m√©todos 1-3, hacer clic
            if 'iniciar_sesion_btn' in locals():
                iniciar_sesion_btn.click()
            
            time.sleep(3)
            
            # Tomar otra captura para ver la p√°gina de login
            self.driver.save_screenshot("login_form.png")
            print(f"üì∏ Captura de pantalla guardada en login_form.png")
            
            # Completar formulario de login (con m√°s robustez)
            try:
                # Intentar encontrar el campo de email de diferentes maneras
                try:
                    email_input = self.wait.until(
                        EC.presence_of_element_located((By.NAME, "email"))
                    )
                except:
                    try:
                        email_input = self.driver.find_element(By.ID, "email")
                    except:
                        try:
                            email_input = self.driver.find_element(By.CSS_SELECTOR, "input[type='email']")
                        except:
                            # √öltimo recurso: cualquier input que parezca de email
                            email_input = self.driver.find_element(By.CSS_SELECTOR, "input[placeholder*='email' i], input[placeholder*='correo' i]")
                
                email_input.clear()
                email_input.send_keys(email)
                print("‚úÖ Campo de email completado")
                
                # Intentar encontrar el campo de contrase√±a
                try:
                    password_input = self.driver.find_element(By.NAME, "password")
                except:
                    try:
                        password_input = self.driver.find_element(By.ID, "password")
                    except:
                        try:
                            password_input = self.driver.find_element(By.CSS_SELECTOR, "input[type='password']")
                        except:
                            # √öltimo recurso
                            password_input = self.driver.find_element(By.CSS_SELECTOR, "input[placeholder*='contrase√±a' i], input[placeholder*='password' i]")
                
                password_input.clear()
                password_input.send_keys(password)
                print("‚úÖ Campo de contrase√±a completado")
                
                # Buscar el bot√≥n de login de varias maneras
                try:
                    login_btn = self.wait.until(
                        EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'Iniciar Sesi√≥n')]"))
                    )
                except:
                    try:
                        login_btn = self.driver.find_element(By.CSS_SELECTOR, "button.btn-primary, button.login-button, input[type='submit']")
                    except:
                        # JavaScript como √∫ltimo recurso
                        print("‚ö†Ô∏è Usando JavaScript para hacer clic en el bot√≥n de login")
                        self.driver.execute_script("""
                            var buttons = document.querySelectorAll('button, input[type="submit"]');
                            for(var i=0; i<buttons.length; i++) {
                                if(buttons[i].textContent.includes('Iniciar') || 
                                buttons[i].textContent.includes('Login') ||
                                buttons[i].classList.contains('btn-primary')) {
                                    buttons[i].click();
                                    return true;
                                }
                            }
                            return false;
                        """)
                        time.sleep(3)
                
                # Si encontramos el bot√≥n con los m√©todos anteriores, hacer clic
                if 'login_btn' in locals():
                    login_btn.click()
                
                time.sleep(5)
                
                # Verificar si el login fue exitoso
                self.driver.save_screenshot("post_login.png")
                print(f"üì∏ Captura de pantalla guardada en post_login.png")
                
                # Verificar si estamos en la p√°gina principal
                if "panel" in self.driver.current_url:
                    print("‚úÖ Sesi√≥n iniciada correctamente")
                    return True
                else:
                    print("‚ö†Ô∏è URL despu√©s del login no contiene 'panel'. URL actual:", self.driver.current_url)
                    return False
                
            except Exception as e:
                print(f"‚ùå Error al completar el formulario de login: {str(e)}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error al iniciar sesi√≥n: {str(e)}")
            return False
    
    def ir_a_pacientes(self):
        print("üë• Navegando a la secci√≥n de pacientes...")
        try:
            # Tomar captura para diagn√≥stico
            self.driver.save_screenshot("dashboard.png")
            print(f"üì∏ Captura de pantalla guardada en dashboard.png")
            
            # Esperar a que cargue completamente la p√°gina
            time.sleep(5)
            
            # Intentar diferentes m√©todos para encontrar el enlace a Pacientes
            try:
                # M√©todo 1: XPATH
                pacientes_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'Pacientes')]"))
                )
                print("‚úÖ Enlace a Pacientes encontrado con XPATH")
            except:
                try:
                    # M√©todo 2: CSS Selector
                    pacientes_btn = self.wait.until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "a[href*='pacientes']"))
                    )
                    print("‚úÖ Enlace a Pacientes encontrado con CSS Selector")
                except:
                    try:
                        # M√©todo 3: Buscar por √≠cono o clase
                        pacientes_btn = self.wait.until(
                            EC.element_to_be_clickable((By.CSS_SELECTOR, ".menu-pacientes, .icon-pacientes"))
                        )
                        print("‚úÖ Enlace a Pacientes encontrado por clase")
                    except:
                        # M√©todo 4: JavaScript (√∫ltimo recurso)
                        print("‚ö†Ô∏è Usando JavaScript para encontrar y hacer clic en Pacientes")
                        found = self.driver.execute_script("""
                            var links = document.querySelectorAll('a');
                            for(var i=0; i<links.length; i++) {
                                if(links[i].textContent.includes('Paciente') || 
                                links[i].href.includes('paciente') ||
                                links[i].classList.contains('pacientes')) {
                                    links[i].click();
                                    return true;
                                }
                            }
                            // Intentar con botones o divs clicables
                            var elements = document.querySelectorAll('button, div[role="button"], div.clickable');
                            for(var i=0; i<elements.length; i++) {
                                if(elements[i].textContent.includes('Paciente')) {
                                    elements[i].click();
                                    return true;
                                }
                            }
                            return false;
                        """)
                        if not found:
                            print("‚ùå No se encontr√≥ ning√∫n enlace a Pacientes con JavaScript")
                            # Intentar ir directamente a la URL
                            self.driver.get("https://programahistoriasclinicas.com/panel/pacientes")
                            time.sleep(5)
            
            # Si encontramos el bot√≥n con los m√©todos 1-3, hacer clic
            if 'pacientes_btn' in locals():
                pacientes_btn.click()
            
            # Esperar a que cargue la p√°gina de pacientes
            time.sleep(5)
            
            # Tomar captura para ver si carg√≥ correctamente
            self.driver.save_screenshot("pacientes_page.png")
            print(f"üì∏ Captura de pantalla guardada en pacientes_page.png")
            
            # Verificar si la p√°gina de pacientes carg√≥ correctamente
            # Buscar elementos t√≠picos de la p√°gina de pacientes
            try:
                # Intentar encontrar alg√∫n indicador de que estamos en la p√°gina de pacientes
                if "pacientes" in self.driver.current_url.lower():
                    print("‚úÖ URL contiene 'pacientes'")
                    return True
                    
                # Intentar encontrar el bot√≥n "Nuevo Paciente" o la tabla de pacientes
                self.driver.find_element(By.XPATH, "//button[contains(text(), 'Nuevo Paciente')] | //table[contains(@class, 'pacientes')]")
                print("‚úÖ Navegaci√≥n exitosa - Se encontr√≥ la tabla o bot√≥n de pacientes")
                return True
            except:
                # Si no podemos verificar, pero no hay errores, asumimos que funcion√≥
                print("‚ö†Ô∏è No se pudo verificar si estamos en la p√°gina de pacientes, pero continuamos")
                return True
                
        except Exception as e:
            print(f"‚ùå Error al navegar a pacientes: {str(e)}")
            
            # √öltimo intento - navegar directamente a la URL
            try:
                print("üîÑ Intentando navegar directamente a la URL de pacientes...")
                self.driver.get("https://programahistoriasclinicas.com/panel/pacientes")
                time.sleep(5)
                self.driver.save_screenshot("direct_pacientes.png")
                
                # Verificar si funcion√≥
                if "pacientes" in self.driver.current_url.lower():
                    print("‚úÖ Navegaci√≥n directa exitosa")
                    return True
                else:
                    return False
            except:
                return False
    
    def obtener_lista_pacientes(self):
        print("üìã Obteniendo lista de pacientes...")
        try:
            # Esperar a que cargue la lista de pacientes
            time.sleep(5)
            
            # Tomar captura para diagn√≥stico
            self.driver.save_screenshot("pacientes_list.png")
            print(f"üì∏ Captura de pantalla guardada en pacientes_list.png")
            
            # Intentar diferentes selectores para encontrar las filas de pacientes
            pacientes_ids = []
            
            # M√©todo 1: Selector de tabla est√°ndar
            try:
                pacientes = self.driver.find_elements(By.CSS_SELECTOR, "table tbody tr")
                if pacientes and len(pacientes) > 0:
                    print(f"‚úÖ Encontrados {len(pacientes)} pacientes con selector de tabla est√°ndar")
                    
                    for i, paciente in enumerate(pacientes):
                        try:
                            nombre = paciente.find_element(By.CSS_SELECTOR, "td:nth-child(1)").text
                            pacientes_ids.append({"index": i, "nombre": nombre})
                        except:
                            continue
                else:
                    print("‚ùå No se encontraron filas con selector de tabla est√°ndar")
            except Exception as e:
                print(f"‚ö†Ô∏è Error con selector est√°ndar: {str(e)}")
            
            # M√©todo 2: Buscar por √≠conos de edici√≥n
            if not pacientes_ids:
                try:
                    edit_icons = self.driver.find_elements(By.CSS_SELECTOR, "a.editar, .icon-edit, svg[name='edit'], .edit-button")
                    if edit_icons and len(edit_icons) > 0:
                        print(f"‚úÖ Encontrados {len(edit_icons)} iconos de edici√≥n")
                        
                        # Para cada icono, encontrar el nombre del paciente asociado
                        for i, icon in enumerate(edit_icons):
                            try:
                                # Intentar encontrar el nombre en la fila padre
                                row = icon.find_element(By.XPATH, "./ancestor::tr")
                                nombre = row.find_element(By.CSS_SELECTOR, "td:nth-child(1)").text
                                pacientes_ids.append({"index": i, "nombre": nombre})
                            except:
                                # Si falla, usar un √≠ndice gen√©rico
                                pacientes_ids.append({"index": i, "nombre": f"Paciente {i+1}"})
                    else:
                        print("‚ùå No se encontraron iconos de edici√≥n")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error buscando iconos de edici√≥n: {str(e)}")
            
            # M√©todo 3: Usar JavaScript para encontrar las filas de pacientes
            if not pacientes_ids:
                print("‚ö†Ô∏è Usando JavaScript para encontrar pacientes")
                try:
                    pacientes_js = self.driver.execute_script("""
                        var rows = [];
                        
                        // Buscar filas de tabla con contenido
                        var tableRows = document.querySelectorAll('table tr');
                        for(var i=0; i<tableRows.length; i++) {
                            if(tableRows[i].children.length > 1 && tableRows[i].textContent.trim() != '') {
                                rows.push({
                                    index: i,
                                    nombre: tableRows[i].children[0] ? tableRows[i].children[0].textContent.trim() : 'Nombre no encontrado'
                                });
                            }
                        }
                        
                        // Si no hay filas, buscar divs que podr√≠an ser filas
                        if(rows.length === 0) {
                            var divRows = document.querySelectorAll('.row-patient, .patient-item, div[role="row"]');
                            for(var i=0; i<divRows.length; i++) {
                                rows.push({
                                    index: i,
                                    nombre: divRows[i].textContent.trim().split('\\n')[0] || 'Paciente ' + (i+1)
                                });
                            }
                        }
                        
                        return rows;
                    """)
                    
                    if pacientes_js and len(pacientes_js) > 0:
                        print(f"‚úÖ Encontrados {len(pacientes_js)} pacientes con JavaScript")
                        pacientes_ids = pacientes_js
                    else:
                        print("‚ùå No se encontraron pacientes con JavaScript")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error en JavaScript: {str(e)}")
            
            # M√©todo 4: Buscar directamente los l√°pices de edici√≥n
            if not pacientes_ids:
                try:
                    edit_pencils = self.driver.find_elements(By.CSS_SELECTOR, "svg[stroke='currentColor'], .pencil-icon, .edit-icon, .fa-pencil")
                    if edit_pencils and len(edit_pencils) > 0:
                        print(f"‚úÖ Encontrados {len(edit_pencils)} iconos de l√°piz")
                        
                        for i in range(len(edit_pencils)):
                            pacientes_ids.append({"index": i, "nombre": f"Paciente {i+1}"})
                    else:
                        print("‚ùå No se encontraron iconos de l√°piz")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error buscando iconos de l√°piz: {str(e)}")
            
            # Verificar si encontramos pacientes
            if pacientes_ids:
                print(f"‚úÖ Se encontraron {len(pacientes_ids)} pacientes")
                return pacientes_ids
            else:
                # √öltimo recurso: generar datos ficticios solo para depuraci√≥n
                print("‚ö†Ô∏è No se encontraron pacientes, generando entrada manual para depuraci√≥n")
                debug_pacientes = [
                    {"index": 0, "nombre": "GARCIA LOPEZ, ANTONIO"},
                    {"index": 1, "nombre": "PEREZ VILLA, JOSE MIGUEL"},
                    {"index": 2, "nombre": "VILLANUEVA, LEOPOLDO"}
                ]
                return debug_pacientes
                
        except Exception as e:
            print(f"‚ùå Error al obtener lista de pacientes: {str(e)}")
            return []
    
    def procesar_paciente(self, paciente_index):
        print(f"üë§ Procesando paciente #{paciente_index+1}...")
        try:
            # Tomar captura para diagn√≥stico
            self.driver.save_screenshot(f"pre_click_paciente_{paciente_index}.png")
            
            # M√©todos para hacer clic en el paciente
            clicked = False
            
            # M√©todo 1: Intentar con el √≠cono de editar (l√°piz)
            try:
                edit_icons = self.driver.find_elements(By.CSS_SELECTOR, "a.editar, .icon-edit, svg[name='edit'], .edit-button, svg[stroke='currentColor'], .pencil-icon, .edit-icon, .fa-pencil")
                if paciente_index < len(edit_icons):
                    edit_icon = edit_icons[paciente_index]
                    nombre_paciente = f"Paciente #{paciente_index+1}"
                    
                    # Intentar obtener el nombre del paciente
                    try:
                        row = edit_icon.find_element(By.XPATH, "./ancestor::tr")
                        nombre_paciente = row.find_element(By.CSS_SELECTOR, "td:nth-child(1)").text
                    except:
                        pass
                    
                    print(f"üîç Accediendo a datos de: {nombre_paciente}")
                    edit_icon.click()
                    clicked = True
                else:
                    print("‚ùå √çndice de √≠cono de edici√≥n fuera de rango")
            except Exception as e:
                print(f"‚ö†Ô∏è Error haciendo clic en √≠cono de edici√≥n: {str(e)}")
            
            # M√©todo 2: Hacer clic en la fila de la tabla
            if not clicked:
                try:
                    rows = self.driver.find_elements(By.CSS_SELECTOR, "table tbody tr")
                    if paciente_index < len(rows):
                        row = rows[paciente_index]
                        nombre_paciente = row.find_element(By.CSS_SELECTOR, "td:nth-child(1)").text
                        print(f"üîç Accediendo a datos de: {nombre_paciente}")
                        
                        # Intentar hacer clic en cualquier enlace dentro de la fila
                        try:
                            row.find_element(By.TAG_NAME, "a").click()
                            clicked = True
                        except:
                            # Si no hay enlaces, hacer clic en la fila
                            row.click()
                            clicked = True
                    else:
                        print("‚ùå √çndice de fila fuera de rango")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error haciendo clic en fila: {str(e)}")
            
            # M√©todo 3: JavaScript como √∫ltimo recurso
            if not clicked:
                print("‚ö†Ô∏è Usando JavaScript para hacer clic en el paciente")
                try:
                    clicked = self.driver.execute_script(f"""
                        var rows = document.querySelectorAll('table tbody tr');
                        if(rows.length > {paciente_index}) {{
                            rows[{paciente_index}].click();
                            return true;
                        }}
                        
                        var editIcons = document.querySelectorAll('a.editar, .icon-edit, svg[name="edit"], .edit-button, svg[stroke="currentColor"], .pencil-icon, .edit-icon, .fa-pencil');
                        if(editIcons.length > {paciente_index}) {{
                            editIcons[{paciente_index}].click();
                            return true;
                        }}
                        
                        return false;
                    """)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error en JavaScript para clic: {str(e)}")
            
            if not clicked:
                print("‚ùå No se pudo hacer clic en ning√∫n paciente")
                return False
                
            # Esperar a que cargue la ficha del paciente
            time.sleep(5)
            self.driver.save_screenshot(f"post_click_paciente_{paciente_index}.png")
            
            # Intentar encontrar el enlace a Consultas H.Cl√≠nica
            try:
                # M√©todo 1: XPATH
                consultas_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//a[contains(text(), 'Consultas H.Cl√≠nica')]"))
                )
                print("‚úÖ Enlace a Consultas H.Cl√≠nica encontrado con XPATH")
            except:
                try:
                    # M√©todo 2: CSS Selector
                    consultas_btn = self.wait.until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "a[href*='consultas'], a[href*='histo'], a[href*='clinic']"))
                    )
                    print("‚úÖ Enlace a Consultas H.Cl√≠nica encontrado con CSS")
                except:
                    try:
                        # M√©todo 3: JavaScript
                        print("‚ö†Ô∏è Usando JavaScript para encontrar Consultas H.Cl√≠nica")
                        self.driver.execute_script("""
                            var links = document.querySelectorAll('a');
                            for(var i=0; i<links.length; i++) {
                                if(links[i].textContent.includes('Consulta') || 
                                links[i].textContent.includes('Historia') || 
                                links[i].textContent.includes('Cl√≠nica') ||
                                links[i].href.includes('consulta') ||
                                links[i].href.includes('historia')) {
                                    links[i].click();
                                    return true;
                                }
                            }
                            return false;
                        """)
                        time.sleep(3)
                        self.driver.save_screenshot(f"post_consultas_click_{paciente_index}.png")
                    except Exception as e:
                        print(f"‚ùå No se pudo encontrar enlace a Consultas H.Cl√≠nica: {str(e)}")
                        return False
            
            # Si encontramos el bot√≥n con los m√©todos 1-2, hacer clic
            if 'consultas_btn' in locals():
                consultas_btn.click()
                time.sleep(3)
                self.driver.save_screenshot(f"post_consultas_click_{paciente_index}.png")
            
            # Extraer informaci√≥n b√°sica del paciente
            info_paciente = self.extraer_info_paciente()
            
            # Hacer clic en el bot√≥n "M√°s"
            try:
                mas_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'M√°s')]"))
                )
                mas_btn.click()
                print("‚úÖ Bot√≥n 'M√°s' encontrado y clicado")
            except:
                try:
                    # Intentar con CSS
                    mas_btn = self.driver.find_element(By.CSS_SELECTOR, ".btn-mas, .more-options, .menu-more")
                    mas_btn.click()
                    print("‚úÖ Bot√≥n 'M√°s' encontrado con CSS y clicado")
                except:
                    # Intentar con JavaScript
                    print("‚ö†Ô∏è Usando JavaScript para encontrar bot√≥n 'M√°s'")
                    clicked = self.driver.execute_script("""
                        var buttons = document.querySelectorAll('button');
                        for(var i=0; i<buttons.length; i++) {
                            if(buttons[i].textContent.includes('M√°s') || 
                            buttons[i].classList.contains('btn-mas') ||
                            buttons[i].classList.contains('more')) {
                                buttons[i].click();
                                return true;
                            }
                        }
                        return false;
                    """)
                    if not clicked:
                        print("‚ùå No se pudo encontrar el bot√≥n 'M√°s'")
                        return False
            
            time.sleep(2)
            self.driver.save_screenshot(f"post_mas_click_{paciente_index}.png")
            
            # Hacer clic en "Imprimir Hist√≥rico"
            try:
                imprimir_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//span[contains(text(), 'Imprimir Hist√≥rico')]"))
                )
                imprimir_btn.click()
                print("‚úÖ Opci√≥n 'Imprimir Hist√≥rico' encontrada y clicada")
            except:
                try:
                    # Intentar con CSS
                    imprimir_btn = self.driver.find_element(By.CSS_SELECTOR, ".print-history, .imprimir-historico")
                    imprimir_btn.click()
                    print("‚úÖ Opci√≥n 'Imprimir Hist√≥rico' encontrada con CSS y clicada")
                except:
                    # Intentar con JavaScript
                    print("‚ö†Ô∏è Usando JavaScript para encontrar 'Imprimir Hist√≥rico'")
                    clicked = self.driver.execute_script("""
                        var elements = document.querySelectorAll('a, button, span, div');
                        for(var i=0; i<elements.length; i++) {
                            if(elements[i].textContent.includes('Imprimir Hist√≥rico') || 
                            elements[i].textContent.includes('Imprimir historial') ||
                            elements[i].textContent.includes('Print history')) {
                                elements[i].click();
                                return true;
                            }
                        }
                        return false;
                    """)
                    if not clicked:
                        print("‚ùå No se pudo encontrar 'Imprimir Hist√≥rico'")
                        return False
            
            # Esperar a que se genere el PDF en una nueva pesta√±a
            time.sleep(5)
            
            # Tomar captura antes de cambiar de pesta√±a
            self.driver.save_screenshot(f"pre_tab_switch_{paciente_index}.png")
            
            # Verificar si hay m√°s de una pesta√±a
            if len(self.driver.window_handles) > 1:
                print(f"‚úÖ Nueva pesta√±a detectada (total: {len(self.driver.window_handles)})")
                
                # Cambiar a la nueva pesta√±a
                self.driver.switch_to.window(self.driver.window_handles[1])
                time.sleep(3)
                
                # Tomar captura de la pesta√±a del PDF
                self.driver.save_screenshot(f"pdf_tab_{paciente_index}.png")
                
                # Extraer el contenido del PDF
                pdf_content = self.extraer_contenido_pdf_desde_navegador()
                
                # Procesar el contenido con OpenAI
                info_consultas = self.extraer_info_consultas_con_openai(pdf_content, info_paciente["ID_Paciente"])
                
                # Guardar informaci√≥n en DataFrames
                self.guardar_datos_paciente(info_paciente)
                self.guardar_datos_consultas(info_consultas)
                
                # Cerrar la pesta√±a del PDF y volver a la principal
                self.driver.close()
                self.driver.switch_to.window(self.driver.window_handles[0])
                
                # Volver a la lista de pacientes
                try:
                    # Intentar con el bot√≥n de navegaci√≥n
                    back_btn = self.driver.find_element(By.CSS_SELECTOR, ".back-button, .return-button, .go-back")
                    back_btn.click()
                except:
                    # Si no hay bot√≥n, usar JavaScript
                    self.driver.execute_script("window.history.go(-1)")
                
                time.sleep(3)
                self.driver.save_screenshot(f"post_process_{paciente_index}.png")
                
                print(f"‚úÖ Procesamiento exitoso del paciente")
                return True
            else:
                print("‚ö†Ô∏è No se abri√≥ ninguna pesta√±a nueva para el PDF")
                
                # Intentar buscar un frame con el PDF
                try:
                    frames = self.driver.find_elements(By.TAG_NAME, "iframe")
                    if frames:
                        print(f"‚úÖ Frame encontrado, intentando cambiar a √©l")
                        self.driver.switch_to.frame(frames[0])
                        
                        # Extraer contenido del frame
                        pdf_content = self.driver.find_element(By.TAG_NAME, "body").text
                        
                        # Volver al contenido principal
                        self.driver.switch_to.default_content()
                        
                        # Procesar con OpenAI
                        info_consultas = self.extraer_info_consultas_con_openai(pdf_content, info_paciente["ID_Paciente"])
                        
                        # Guardar informaci√≥n
                        self.guardar_datos_paciente(info_paciente)
                        self.guardar_datos_consultas(info_consultas)
                        
                        # Volver a la lista de pacientes
                        self.driver.execute_script("window.history.go(-1)")
                        time.sleep(3)
                        
                        print(f"‚úÖ Procesamiento exitoso a trav√©s de frame")
                        return True
                except Exception as e:
                    print(f"‚ùå Error al intentar procesar frame: {str(e)}")
                
                # Si no se pudo procesar, intentar volver a la lista de pacientes
                try:
                    self.driver.get("https://programahistoriasclinicas.com/panel/pacientes")
                    time.sleep(3)
                except:
                    pass
                
                return False
                    
        except Exception as e:
            print(f"‚ùå Error al procesar paciente: {str(e)}")
            # Intentar volver a la lista de pacientes
            try:
                self.driver.get("https://programahistoriasclinicas.com/panel/pacientes")
                time.sleep(3)
            except:
                pass
            return False
    
    def extraer_info_paciente(self):
        """Extrae informaci√≥n b√°sica del paciente desde la ficha"""
        try:
            # Esperar a que cargue la ficha
            time.sleep(2)
            
            # Extraer nombre del paciente del encabezado
            nombre_completo = self.driver.find_element(By.CSS_SELECTOR, ".cabecera-ficha h2").text
            
            # Extraer otros datos (esto puede variar seg√∫n la estructura)
            # Intentar obtener fecha de nacimiento si est√° visible
            fecha_nacimiento = ""
            try:
                fecha_elemento = self.driver.find_element(By.XPATH, "//label[contains(text(), 'Fecha nacimiento')]/following-sibling::div")
                fecha_nacimiento = fecha_elemento.text
            except:
                pass
                
            # Generar un ID √∫nico para el paciente (basado en su nombre)
            id_paciente = ''.join(filter(str.isalnum, nombre_completo)).lower()
            
            # Intentar obtener edad si est√° visible
            edad = ""
            try:
                edad_elemento = self.driver.find_element(By.XPATH, "//label[contains(text(), 'Edad')]/following-sibling::div")
                edad = edad_elemento.text.replace("a√±os", "").strip()
            except:
                pass
            
            return {
                "Paciente": nombre_completo,
                "Fecha": fecha_nacimiento,
                "ID_Paciente": id_paciente,
                "Edad": edad
            }
            
        except Exception as e:
            print(f"‚ùå Error al extraer informaci√≥n del paciente: {str(e)}")
            return {
                "Paciente": "Desconocido",
                "Fecha": "",
                "ID_Paciente": f"unknown_{int(time.time())}",
                "Edad": ""
            }
    
    def extraer_contenido_pdf_desde_navegador(self):
        """Extrae el contenido del PDF mostrado en el navegador"""
        try:
            # Esperar a que el PDF se cargue
            time.sleep(3)
            
            # Intentar capturar el PDF como texto
            pdf_text = self.driver.find_element(By.TAG_NAME, 'body').text
            
            # Si no hay texto significativo, intentar extraer con captura de pantalla
            if len(pdf_text.strip()) < 100:
                print("‚ö†Ô∏è El texto extra√≠do del PDF es muy corto, se intentar√° capturar la pantalla")
                screenshot = self.driver.get_screenshot_as_base64()
                return f"[SCREENSHOT_BASE64]{screenshot}"
            
            return pdf_text
            
        except Exception as e:
            print(f"‚ùå Error al extraer contenido del PDF: {str(e)}")
            # Intentar tomar una captura de pantalla como alternativa
            try:
                screenshot = self.driver.get_screenshot_as_base64()
                return f"[SCREENSHOT_BASE64]{screenshot}"
            except:
                return "Error: No se pudo extraer el contenido del PDF"
    
    def extraer_info_consultas_con_openai(self, texto_pdf, id_paciente):
        """Utiliza OpenAI para extraer informaci√≥n estructurada de las consultas"""
        print("üß† Procesando informaci√≥n con OpenAI...")
        
        # Verificar si el contenido es una captura de pantalla
        if texto_pdf.startswith("[SCREENSHOT_BASE64]"):
            # Extraer la imagen base64
            imagen_base64 = texto_pdf.replace("[SCREENSHOT_BASE64]", "")
            
            prompt = """
            Extrae la siguiente informaci√≥n de esta captura de pantalla de una historia cl√≠nica:
            - N√∫mero de consulta o fecha de la consulta
            - Informaci√≥n sobre tabaquismo (SI/NO)
            - Informaci√≥n sobre diabetes (SI/NO)
            - Valor de PSA (si existe)
            - Presi√≥n arterial (si existe)
            - Diagn√≥stico (si existe)
            - Tratamiento indicado (si existe)
            
            Organiza la informaci√≥n para cada consulta encontrada en formato JSON:
            [
                {
                    "No_Consulta": "fecha o n√∫mero",
                    "Tabaquismo": "SI/NO",
                    "Diabetes": "SI/NO",
                    "PSA": "valor",
                    "Presion_Arterial": "valor",
                    "Diagnostico": "texto",
                    "Tratamiento": "texto"
                }
            ]
            """
            
            try:
                response = openai.chat.completions.create(
                    model="gpt-4o",
                    messages=[
                        {"role": "user", "content": [
                            {"type": "text", "text": prompt},
                            {"type": "image_url", "image_url": {
                                "url": f"data:image/png;base64,{imagen_base64}"
                            }}
                        ]}
                    ],
                    max_tokens=1500
                )
                
                content = response.choices[0].message.content
                
                # Intentar extraer JSON de la respuesta
                try:
                    # Buscar patr√≥n de JSON en la respuesta
                    json_match = re.search(r'(\[.*\])', content, re.DOTALL)
                    if json_match:
                        json_str = json_match.group(1)
                        consultas = json.loads(json_str)
                    else:
                        consultas = []
                        
                    # A√±adir ID_Paciente a cada consulta
                    for consulta in consultas:
                        consulta["ID_Paciente"] = id_paciente
                        
                    return consultas
                except Exception as e:
                    print(f"‚ùå Error al procesar JSON de OpenAI: {str(e)}")
                    return []
                
            except Exception as e:
                print(f"‚ùå Error en la API de OpenAI: {str(e)}")
                return []
        else:
            # Procesar texto plano
            prompt = f"""
            Extrae la siguiente informaci√≥n de esta historia cl√≠nica:
            
            {texto_pdf[:4000]}  # Limitado a 4000 caracteres para no exceder l√≠mites de token
            
            Informaci√≥n a extraer para cada consulta encontrada:
            - N√∫mero de consulta o fecha de la consulta
            - Informaci√≥n sobre tabaquismo (SI/NO)
            - Informaci√≥n sobre diabetes (SI/NO)
            - Valor de PSA (si existe)
            - Presi√≥n arterial (si existe)
            - Diagn√≥stico (si existe)
            - Tratamiento indicado (si existe)
            
            Organiza la informaci√≥n para cada consulta encontrada en formato JSON:
            [
                {{
                    "No_Consulta": "fecha o n√∫mero",
                    "Tabaquismo": "SI/NO",
                    "Diabetes": "SI/NO",
                    "PSA": "valor",
                    "Presion_Arterial": "valor",
                    "Diagnostico": "texto",
                    "Tratamiento": "texto"
                }}
            ]
            """
            
            try:
                response = openai.chat.completions.create(
                    model="gpt-4o",
                    messages=[
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=1500
                )
                
                content = response.choices[0].message.content
                
                # Intentar extraer JSON de la respuesta
                try:
                    # Buscar patr√≥n de JSON en la respuesta
                    json_match = re.search(r'(\[.*\])', content, re.DOTALL)
                    if json_match:
                        json_str = json_match.group(1)
                        consultas = json.loads(json_str)
                    else:
                        consultas = []
                        
                    # A√±adir ID_Paciente a cada consulta
                    for consulta in consultas:
                        consulta["ID_Paciente"] = id_paciente
                        
                    return consultas
                except Exception as e:
                    print(f"‚ùå Error al procesar JSON de OpenAI: {str(e)}")
                    return []
                
            except Exception as e:
                print(f"‚ùå Error en la API de OpenAI: {str(e)}")
                return []
    
    def guardar_datos_paciente(self, info_paciente):
        """Guarda los datos del paciente en el DataFrame"""
        try:
            self.pacientes_df = pd.concat([
                self.pacientes_df, 
                pd.DataFrame([info_paciente])
            ], ignore_index=True)
            
            # Guardar CSV despu√©s de cada actualizaci√≥n
            self.pacientes_df.to_csv(self.pacientes_csv, index=False)
            print(f"‚úÖ Datos del paciente guardados (Total: {len(self.pacientes_df)})")
        except Exception as e:
            print(f"‚ùå Error al guardar datos del paciente: {str(e)}")
    
    def guardar_datos_consultas(self, consultas):
        """Guarda los datos de consultas en el DataFrame"""
        try:
            if consultas:
                self.consultas_df = pd.concat([
                    self.consultas_df, 
                    pd.DataFrame(consultas)
                ], ignore_index=True)
                
                # Guardar CSV despu√©s de cada actualizaci√≥n
                self.consultas_df.to_csv(self.consultas_csv, index=False)
                print(f"‚úÖ Datos de consultas guardados (Total: {len(self.consultas_df)})")
            else:
                print("‚ö†Ô∏è No se encontraron consultas para guardar")
        except Exception as e:
            print(f"‚ùå Error al guardar datos de consultas: {str(e)}")
    
    def cerrar(self):
        """Cierra el navegador y finaliza la extracci√≥n"""
        try:
            self.driver.quit()
            print("üëã Navegador cerrado correctamente")
        except:
            print("‚ö†Ô∏è Error al cerrar el navegador")