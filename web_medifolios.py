from selenium.webdriver.common.by import By 
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
import time

class HistoriasClinicasExtractor:
    def __init__(self):
        chrome_options = Options()
        chrome_options.add_argument("--start-maximized")
        chrome_options.add_argument("--disable-notifications")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        
        self.driver = webdriver.Chrome(options=chrome_options)
        self.wait = WebDriverWait(self.driver, 10)

    def login(self, usuario, password):
        print(f"üîë Iniciando sesi√≥n con usuario: {usuario}")
        self.driver.get("https://www.medifolios.net")

        # Click en bot√≥n INGRESO
        try:
            # Usando el selector m√°s espec√≠fico seg√∫n el HTML proporcionado
            ingreso_btn = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'server0medifolios.net') and contains(@class, 'block-menu')]"))
            )
            ingreso_btn.click()
            print("‚úÖ Bot√≥n INGRESO clicado")
        except Exception as e:
            print(f"‚ùå Error clicando en INGRESO: {str(e)}")
            return False

        # Completar formulario de login
        try:
            usuario_input = self.wait.until(EC.presence_of_element_located((By.ID, "txt_usuario_login")))
            password_input = self.driver.find_element(By.ID, "txt_password_login")
            usuario_input.send_keys(usuario)
            password_input.send_keys(password)

            login_btn = self.driver.find_element(By.XPATH, "//button[contains(text(),'Ingresar')]")
            login_btn.click()
            print("‚úÖ Formulario de login enviado")
            
            # Esperar a que cargue la p√°gina principal despu√©s del login
            time.sleep(5)
            return True
        except Exception as e:
            print(f"‚ùå Error en formulario de login: {str(e)}")
            return False

    def navegar_a_pacientes(self):
        try:
            # Click en men√∫ Bienvenido (abre el men√∫)
            menu_bienvenido = self.wait.until(
                EC.element_to_be_clickable((By.ID, "OpenMenuMedifolios"))
            )
            menu_bienvenido.click()
            print("‚úÖ Men√∫ Bienvenido clicado")
            time.sleep(3)

            # Click en Pacientes (seg√∫n el selector HTML proporcionado)
            try:
                # Primer intento con selector m√°s espec√≠fico
                pacientes_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//div[contains(@class,'item_menu_board')]//a[contains(@href,'SALUD_HOME/paciente')]"))
                )
                pacientes_btn.click()
                print("‚úÖ Secci√≥n pacientes abierta (selector espec√≠fico)")
            except Exception as e:
                print(f"‚ö†Ô∏è Primer selector fall√≥, intentando alternativa: {str(e)}")
                # Segundo intento con selector m√°s gen√©rico
                pacientes_btn = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, "//a[contains(@href,'SALUD_HOME/paciente')]"))
                )
                pacientes_btn.click()
                print("‚úÖ Secci√≥n pacientes abierta (selector gen√©rico)")
            time.sleep(5)  # Esperar m√°s tiempo para que cargue la secci√≥n de pacientes
        except Exception as e:
            print(f"‚ùå Error navegando a pacientes: {str(e)}")

    def abrir_listado_pacientes(self):
        try:
            # Click en bot√≥n Listado Pacientes
            listado_btn = self.wait.until(
                EC.element_to_be_clickable((By.CLASS_NAME, "btnListadoPacientes"))
            )
            listado_btn.click()
            print("‚úÖ Listado de pacientes abierto")
            time.sleep(3)
            
            # Click en bot√≥n editar (el primero que encuentre)
            editar_btn = self.wait.until(
                EC.element_to_be_clickable((By.CLASS_NAME, "btnCodPacienteListado"))
            )
            editar_btn.click()
            print("‚úÖ Bot√≥n editar clicado")
            time.sleep(3)  # Esperar a que aparezca el di√°logo
        except Exception as e:
            print(f"‚ùå Error en listado de pacientes: {str(e)}")
            
    def cerrar_ventana(self):
        try:
            print("üîç Buscando bot√≥n de cierre (X) en la ventana...")
            
            # Intentar m√∫ltiples selectores para encontrar el bot√≥n X
            selectors = [
                "//button[contains(@class, 'ui-dialog-titlebar-close')]",                   # Xpath general
                "//span[@class='ui-button-icon-primary ui-icon ui-icon-closethick']/parent::button",  # Por el √≠cono
                "//button[@title='Close']",                                                # Por el t√≠tulo
                "//div[contains(@class,'ui-dialog')]/div/button",                          # Por la estructura del di√°logo
                "//button[contains(@class,'close')]"                                       # Selector gen√©rico para botones de cierre
            ]
            
            for i, selector in enumerate(selectors):
                try:
                    close_btn = self.wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    close_btn.click()
                    print(f"‚úÖ Ventana cerrada usando selector #{i+1}")
                    time.sleep(3)  # Esperar a que se cierre la ventana
                    return True
                except Exception as e:
                    print(f"‚ö†Ô∏è Selector #{i+1} fall√≥: {str(e)[:100]}...")
            
            # Si llegamos aqu√≠, intentemos con JavaScript
            try:
                print("üîß Intentando cerrar ventana con JavaScript...")
                # Intentar m√∫ltiples opciones de JavaScript
                js_commands = [
                    "document.querySelector('.ui-dialog-titlebar-close').click();",
                    "document.querySelector('button[title=\"Close\"]').click();",
                    "document.querySelectorAll('.ui-button.ui-dialog-titlebar-close')[0].click();",
                    "var buttons = document.getElementsByTagName('button'); for(var i=0; i<buttons.length; i++) { if(buttons[i].title === 'Close') buttons[i].click(); }",
                    "document.querySelector('.ui-icon-closethick').parentNode.click();"
                ]
                
                for cmd in js_commands:
                    try:
                        self.driver.execute_script(cmd)
                        print("‚úÖ Ventana cerrada usando JavaScript")
                        time.sleep(3)
                        return True
                    except Exception as js_e:
                        print(f"‚ö†Ô∏è Comando JS fall√≥: {str(js_e)[:50]}...")
            except Exception as e:
                print(f"‚ö†Ô∏è Error general con JavaScript: {str(e)[:100]}...")
            
            # √öltima opci√≥n: Presionar tecla ESC
            print("üîë Intentando cerrar con tecla ESC...")
            from selenium.webdriver.common.keys import Keys
            from selenium.webdriver.common.action_chains import ActionChains
            
            actions = ActionChains(self.driver)
            actions.send_keys(Keys.ESCAPE).perform()
            time.sleep(2)
            
            # Verificar si hay un overlay y removerlo si existe
            self._limpiar_overlays()
            
            return False
        except Exception as e:
            print(f"‚ùå Error general al cerrar ventana: {str(e)}")
            return False
            
    def _limpiar_overlays(self):
        """M√©todo auxiliar para limpiar overlays que puedan estar bloqueando la interfaz"""
        try:
            # Buscar todos los posibles overlays
            overlays = self.driver.find_elements(By.CSS_SELECTOR, 
                "div.ui-widget-overlay, div.ui-front, div.modal-backdrop, div.modal")
            
            if overlays:
                print(f"‚ö†Ô∏è Detectados {len(overlays)} overlays, intentando removerlos...")
                for overlay in overlays:
                    try:
                        self.driver.execute_script("arguments[0].remove();", overlay)
                    except:
                        pass  # Ignorar errores individuales
                print("‚úÖ Overlays removidos")
            
            # Tambi√©n intentar con script gen√©rico
            self.driver.execute_script("""
                var overlays = document.querySelectorAll('.ui-widget-overlay, .ui-front, .modal-backdrop, .modal');
                for(var i=0; i<overlays.length; i++) {
                    overlays[i].remove();
                }
            """)
            
            time.sleep(1)  # Breve pausa
        except Exception as e:
            print(f"‚ÑπÔ∏è Limpieza de overlays: {str(e)[:100]}...")

    def visualizar_historia(self):
        try:
            # Dar tiempo para que la p√°gina se estabilice despu√©s de cerrar di√°logos
            time.sleep(3)
            
            # Limpiar posibles overlays antes de interactuar con el historial
            self._limpiar_overlays()
            
            print("üîç Buscando bot√≥n de historial cl√≠nico...")
            
            # Intentar hacer clic con JavaScript primero (m√°s confiable cuando hay problemas de superposici√≥n)
            try:
                historial_btn = self.wait.until(
                    EC.presence_of_element_located((By.ID, "btnPanelHistorico"))
                )
                # Hacer scroll al elemento para asegurarnos que est√° visible
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", historial_btn)
                time.sleep(1)  # Breve pausa despu√©s del scroll
                
                # Hacer clic con JavaScript
                self.driver.execute_script("arguments[0].click();", historial_btn)
                print("‚úÖ Historial de paciente abierto (usando JavaScript)")
            except Exception as e:
                print(f"‚ö†Ô∏è Error al hacer clic en historial con JavaScript: {str(e)[:100]}...")
                # √öltimo intento con clic normal
                try:
                    historial_btn = self.wait.until(
                        EC.element_to_be_clickable((By.ID, "btnPanelHistorico"))
                    )
                    historial_btn.click()
                    print("‚úÖ Historial de paciente abierto (clic normal)")
                except Exception as e2:
                    print(f"‚ùå No se pudo acceder al historial: {str(e2)[:100]}...")
                    raise Exception("No se pudo acceder al historial cl√≠nico")
            
            # Esperar a que cargue el panel de historial
            time.sleep(5)
            
            # Seleccionar todas las historias usando JavaScript
            try:
                print("üîç Buscando checkbox para seleccionar historias...")
                checkbox = self.wait.until(
                    EC.presence_of_element_located((By.ID, "btnSeleccionarHistorias"))
                )
                # Hacer scroll y asegurar visibilidad
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", checkbox)
                time.sleep(1)
                # Clic con JavaScript
                self.driver.execute_script("arguments[0].click();", checkbox)
                print("‚úÖ Historias seleccionadas (usando JavaScript)")
            except Exception as e:
                print(f"‚ùå Error al seleccionar historias: {str(e)[:100]}...")
                raise Exception("No se pudieron seleccionar las historias")

            time.sleep(2)

            # Visualizar seleccionado con JavaScript
            try:
                print("üîç Buscando bot√≥n para visualizar seleccionado...")
                visualizar_btn = self.wait.until(
                    EC.presence_of_element_located((By.ID, "btnVisualizarSeleccionado"))
                )
                # Hacer scroll y asegurar visibilidad
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", visualizar_btn)
                time.sleep(1)
                # Clic con JavaScript
                self.driver.execute_script("arguments[0].click();", visualizar_btn)
                print("‚úÖ Visualizando historias seleccionadas (usando JavaScript)")
            except Exception as e:
                print(f"‚ùå Error al visualizar historias: {str(e)[:100]}...")
                raise Exception("No se pudieron visualizar las historias seleccionadas")

            time.sleep(4)

            # Imprimir con JavaScript
            try:
                print("üîç Buscando bot√≥n para imprimir...")
                imprimir_btn = self.wait.until(
                    EC.presence_of_element_located((By.ID, "btn_imprimir_visualizar_historia"))
                )
                # Hacer scroll y asegurar visibilidad
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", imprimir_btn)
                time.sleep(1)
                # Clic con JavaScript
                self.driver.execute_script("arguments[0].click();", imprimir_btn)
                print("‚úÖ Historia cl√≠nica visualizada e impresa (usando JavaScript)")
            except Exception as e:
                print(f"‚ùå Error al imprimir historia: {str(e)[:100]}...")
                raise Exception("No se pudo imprimir la historia cl√≠nica")

            time.sleep(3)
            print("üéâ Proceso de visualizaci√≥n de historia cl√≠nica completado exitosamente")
        except Exception as e:
            print(f"‚ùå Error al visualizar historia cl√≠nica: {str(e)}")
    
    def cerrar(self):
        print("üëã Cerrando navegador...")
        try:
            self.driver.quit()
            print("‚úÖ Navegador cerrado correctamente")
        except Exception as e:
            print(f"‚ö†Ô∏è Error al cerrar el navegador: {str(e)}")

# -----------------------------------------------------
# MAIN PARA EJECUCI√ìN DESDE ESTE MISMO ARCHIVO
# -----------------------------------------------------

if __name__ == "__main__":
    print("üöÄ Iniciando proceso en Medifolios...")

    # Credenciales directamente aqu√≠
    USUARIO = "80235068"
    PASSWORD = "8U135gf1M"

    extractor = HistoriasClinicasExtractor()

    try:
        if not extractor.login(USUARIO, PASSWORD):
            print("‚ùå Fall√≥ el inicio de sesi√≥n. Finalizando.")
            extractor.cerrar()
            exit()

        extractor.navegar_a_pacientes()
        extractor.abrir_listado_pacientes()
        
        print("üßπ Limpiando ventanas antes de continuar...")
        extractor.cerrar_ventana()  # Cerrar la ventana despu√©s de abrir el listado
        
        print("üìã Accediendo al historial cl√≠nico...")
        extractor.visualizar_historia()

        print("‚úÖ Proceso completado con √©xito")

    except Exception as e:
        print(f"‚ùå Error inesperado: {str(e)}")

    finally:
        extractor.cerrar()